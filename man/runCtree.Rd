% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ctree.funs.r
\name{runCtree}
\alias{runCtree}
\title{run conditional inference tree with additional support}
\usage{
runCtree(
  df1,
  cohort,
  oDir,
  yi = 1,
  pCut = 0.05,
  naCut = 0.3,
  recursive = T,
  getReturn = T,
  ctrlParas = list(minsplit = 10, minbucket = 5, maxsurrogate = 2, alpha = pCut),
  gList = NULL
)
}
\arguments{
\item{df1}{data.frame; columns are variables and rows are observations}

\item{cohort}{char; name of the observation cohort as an annotation in the drawn tree}

\item{oDir}{char; output directory for the tree plot and a summary excel file;
\itemize{
\item one pdf file for each tree
\item each file is named as \code{paste0(oDir,.Platform$file.sep, cohort,'.',yName,'.',gList$counter,'.pdf')}
\item The excel file is the content of \code{stats} from the @return (see below), and
is named as \code{paste0(oDir,.Platform$file.sep,cohort,'.xlsx')}
}}

\item{yi}{int; index of y variable}

\item{pCut}{p-val for significant association; not adjusted.}

\item{naCut}{0-1; columns with > naCut portion won't be considered.}

\item{recursive}{logical;
\itemize{
\item F: only produce the best tree
\item T: produce all trees meeting \code{pCut}
}}

\item{getReturn}{logical; if T, return a list below; no returns otherwise.
it's also used to reduce the internal data transfer load if \code{recursive = T}.}

\item{ctrlParas}{list; parameters for \code{\link[partykit:ctree_control]{partykit::ctree_control()}}}

\item{gList}{a listenv list; it's for internal recursion tracking; users
should ignore this argument.}
}
\value{
if \code{getReturn}, a list of following items; none otherwise.
\itemize{
\item \code{df}: cleaned df1; NA if df1 has only one column or < 10 rows with y values.
\item \code{stats}: possible values:
\itemize{
\item NA \code{ctree()} doesn't run due to one of the following reasons:
\itemize{
\item only one column in \code{df1}
\item < 10 rows where y is not NA
\item y has low variance and is removed by \code{rmNZV()}
\item no tree fitting the \code{pCut} is found. In this case, try increasing \code{pCut}
}
\item A data.frame of following columns, one tree per row
\itemize{
\item counter: the index of each tree drawing
\item cohort, y, pCutoff
\item spVar1,pVal1: the name and p-val of the splitting variable at node 1
\item nNode: number of nodes of the tree
\item spVars: a string containing the names and stats of all splitting
variables. for each node, the format is "name,p-val,cut,gtOnRight"
nodes are separated by ';'.
\item plot: the path to the tree plot
}
}
}
}
\description{
The \code{\link[partykit:ctree]{partykit::ctree()}} function only gives the best separation at each node,
i.e. one tree. This wrapper provides the following supports:
\itemize{
\item By setting \code{recursive = T}, all trees meeting p-val cutoff are produced
and saved. Recursion is done by removing the 1st splitting variable from
the df1 and running \code{runCtree()} inside \code{runCtree()}.
\item The info and stats of each node of each tree are collected and summarized
in an excel file, which also contains ULRs to each tree.
\item Before running \code{partykit::ctree()}, low-informative columns and rows are
removed to reduce computation and adjustment on association p-vals
}
}
\details{
Note:
\itemize{
\item packages \code{partykit} and \code{openxlsx} are loaded, but not attached, in this function.
\item ctree uses \code{coin::independence_test()} to test the association of two
variables of any data type. See \href{https://cran.r-project.org/web/packages/coin/vignettes/LegoCondInf.pdf}{here}
for theory behind the test, and \href{https://stats.stackexchange.com/questions/404589/ctree-in-r-how-optimal-is-the-optimal-split-point}{here}
for an explanation of the algorithm.
}
}
\examples{
# none
}
